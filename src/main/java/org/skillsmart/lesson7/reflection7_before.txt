При проектировании АТД HashTable основная сложность была вокруг двух методов: find() и remove()
По запросу find():
Здесь проблема в возвращаемом значении:
1. Возврат индекса в хэш-таблице.
Минусы: зачем пользователю класса информация о внутренней структуре хранилища, что значение лежит по какому-то по конкретному индексу? Нужно предусловие (проверка) наличия индекса в рамках таблицы.
С другой стороны: по сути мы запрашиваем ключ (и его фактическое наличие) из пары "ключ-значение".
Или:
2. Возврат boolean нашел/не нашел (есть значение в таблице/нет искомого значения). И никаких лишних статусов, "магических" значений типа index = -1.
Но это фактически не find(), а contains()

По команде remove():
И вот тут некоторым образом связанная проблема: что удалять этой командой, какой у нее будет параметр.
Удалять по значению remove(T value) или удалять по индексу remove(int index);

Если команда find() возвращает как в курсе АСД индекс элемента, если он есть, и -1 если его нет, то возможен вариант удаления по индексу,
т.к. все равно в реализации удаления по значению мы сначала найдем индекс, по которому лежит это значение и только потом удалим.
Т.е. команда remove(T value) в этом случае может быть выражена через команды find() и remove(index).
Но,
а) Если реализовать в АСД вариант boolean find(), то remove(index) не реализуем - нам неоткуда взять index элемента.
б) Видится как бы более привычным и удобным удаление именно по значению.
в) Но как кажется, не получаем ли мы тут
"всегда следует избегать формирования операций АТД, подразумевающих некоторую жёсткую последовательность действий или взаимозависимости.
Каждая операция должна быть полностью автономна и независима от других, а ограничения для неё задаются исключительно с помощью пред- и постусловий"

В общем на данном этапе понимания у меня есть возражения против обоих вариантов :(

----------------------------------------------
Конструктор: идентичен
Команды:
put(T value) - все таки для системы разрешения коллизий, даже несмотря на пояснение в задании, я все равно, по сути, привязался к конкретной ее реализации (поведению).
Предполагал, что она обязана найти свободный слот в случае, если таблица неполная. Хотя в общем случае конечно не обязана.
Из этого такое различие в предусловии: в моем предусловие указано наличие просто свободного слота (т.е. таблица не полная), а не точнее как в эталоне: конкретно свободный слот для value.
Ну и соответственно ошибочный статус у меня привязан к конкретной реализации: таблица не полная

Ну а дальше фундаментальное отличие в методах remove() и get().
В процессе проектирования АТД долго думал, выбирал между двумя возможными вариантами. К сожалению, на данном этапе понимания материала у меня были возражения против обоих вариантов

// предусловие: в таблице имеется значение value;
// постусловие: из таблицы удалено значение value
public void remove(T value);

// предусловие: индекс находится в разрешенном диапазоне
    // постусловие: слот с указанным индексом очищен
    public abstract void remove(int index); // предположил, что здесь уместнее параметр индекс, т.к. мы его получаем из find() по значению


// запросы
public bool get(T value); // содержится ли значение value в таблице

public abstract int find(T value); // получить индекс элемента
