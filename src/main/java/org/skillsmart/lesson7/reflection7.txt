При проектировании АТД HashTable основная сложность была вокруг двух методов: find() и remove()
По запросу find():
Здесь проблема в возвращаемом значении:
1. Возврат индекса в хэш-таблице.
Минусы: зачем пользователю класса информация о внутренней структуре хранилища, что значение лежит по какому-то по конкретному индексу? Нужно предусловие (проверка) наличия индекса в рамках таблицы.
С другой стороны: по сути мы запрашиваем ключ (и его фактическое наличие) из пары "ключ-значение".
Или:
2. Возврат boolean нашел/не нашел (есть значение в таблице/нет искомого значения). И никаких лишних статусов, "магических" значений типа index = -1.
Но это фактически не find(), а contains()

По команде remove():
И вот тут некоторым образом связанная проблема: что удалять этой командой, какой у нее будет параметр.
Удалять по значению remove(T value) или удалять по индексу remove(int index);

Если команда find() возвращает как в курсе АСД индекс элемента, если он есть, и -1 если его нет, то возможен вариант удаления по индексу,
т.к. все равно в реализации удаления по значению мы сначала найдем индекс, по которому лежит это значение и только потом удалим.
Т.е. команда remove(T value) в этом случае может быть выражена через команды find() и remove(index).
Но,
а) Если реализовать в АСД вариант boolean find(), то remove(index) не реализуем - нам неоткуда взять index элемента.
б) Видится как бы более привычным и удобным удаление именно по значению.
в) Но как кажется, не получаем ли мы тут
"всегда следует избегать формирования операций АТД, подразумевающих некоторую жёсткую последовательность действий или взаимозависимости.
Каждая операция должна быть полностью автономна и независима от других, а ограничения для неё задаются исключительно с помощью пред- и постусловий"

В общем на данном этапе понимания у меня есть возражения против обоих вариантов :(