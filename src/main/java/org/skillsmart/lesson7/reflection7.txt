put(T value) - все таки для системы разрешения коллизий, даже несмотря на пояснение в задании, я все равно, по сути, привязался к конкретной ее реализации (поведению).
Предполагал, что она обязана найти свободный слот в случае, если таблица неполная. Хотя в общем случае конечно не обязана.
Из этого такое различие в предусловии: в моем предусловие указано наличие просто свободного слота (т.е. таблица не полная), а не точнее как в эталоне: конкретно свободный слот для value.
Ну и соответственно ошибочный статус у меня привязан к конкретной реализации: таблица не полная

Ну а дальше фундаментальное отличие в методах remove() и get().
В процессе проектирования АТД долго думал, выбирал между двумя возможными вариантами. К сожалению, на данном этапе понимания материала у меня были возражения против обоих.
Ну и выбрал все таки не тот.
По вариантам рассуждал следующим образом (рассуждал в процессе написания АТД):
По запросу find() (get()):
Здесь проблема в возвращаемом значении:
1. Возврат индекса в хэш-таблице.
Минусы: зачем пользователю класса информация о внутренней структуре хранилища, что значение лежит по какому-то по конкретному индексу? Нужно предусловие (проверка) наличия индекса в рамках таблицы.
С другой стороны: при поиске мы по сути запрашиваем ключ (и его фактическое наличие) из пары "ключ-значение".
Или:
2. Возврат boolean нашел/не нашел (есть значение в таблице/нет искомого значения). И никаких лишних статусов, "предопределенных" значений типа index = -1.
Но это фактически не find()/get(), а contains()

По команде remove():
И вот тут некоторым образом связанная проблема: что удалять этой командой, какой у нее будет параметр.
Удалять по значению remove(T value) или удалять по индексу remove(int index);

Если команда find() возвращает как в курсе АСД индекс элемента, если он есть, и -1 если его нет, то возможен вариант удаления по индексу,
т.к. все равно в реализации удаления по значению мы сначала найдем индекс, по которому лежит это значение и только потом удалим.
Т.е. команда remove(T value) в этом случае может быть выражена через команды find() и remove(index).
Но,
а) Если реализовать в АТД вариант boolean find(), то remove(index) не реализуем - нам неоткуда взять index элемента.
б) Видится как бы более привычным и удобным удаление именно по значению, а не по индексу.
в) Но как кажется, не получаем ли мы тут
"всегда следует избегать формирования операций АТД, подразумевающих некоторую жёсткую последовательность действий или взаимозависимости.
Каждая операция должна быть полностью автономна и независима от других, а ограничения для неё задаются исключительно с помощью пред- и постусловий"

В общем не пересилил инерцию от необходимости получения индекса (ключа) по find() хотя и думал, что remove(value) логичней и естественней, и поэтому достаточен простой bool contains(), а не int find().
